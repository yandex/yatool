## ya make: основной сборочный инструмент

Это команда для автоматизации сборки проектов, включая компиляцию кода, запуск тестов и создание исполняемых файлов.

Цель сборки в системе `ya make` — это программа или библиотека, которую нужно собрать.  
Цель сборки имеет двоякое значение:
1. Артефакт — результат сборки, например, файл программы или библиотеки.
2. Описание сборки — файл `ya.make`, содержащий инструкции по сборке.

Не каждая цель сборки создает артефакт. 
Некоторые цели устанавливают зависимости или внедряют сборочные флаги.

Цель сборки указывается директорией, содержащей файл `ya.make`. 
Файл `ya.make` описывает, что и как будет собрано и какие цели нужно собрать. 
Результаты сборки по умолчанию размещаются в директориях целей как символьные ссылки.

Правило системы `ya make`:
**Одна директория — одна цель сборки**.
В каждой директории есть только один файл `ya.make`, описывающий сборку одного модуля.

Общая форма команды

`ya make [OPTIONS]… [TARGET]…`

- `[OPTIONS]…` — опции для изменения поведения сборки или тестирования. 
- `[TARGET]…` — цели сборки.
При отсутствии явно указанной цели, `ya make` собирает цель из текущей директории.

`ya make` с помощью опций позволяет гибко настраивать параметры сборки:

- [Тип и вид сборки](#Опции-сборки) — debug/release, LTO, sanitizers и другие.
- [Платформенные параметры](#Платформенные-параметры) — целевые аппаратная платформа и OS, настройки сборочной платформы.
- [Сборочные переменные](#Сборочные-переменные) — например, `-DCFLAGS=-Wall`, `-DDEBUGINFO_LINES_ONLY`.
- [Настройки сборки](#Настройки-сборки) — выбор дополнительных результатов сборки.
- [Работа с тестами](#Работа-с-тестами) - запуск и работа с тестами. 

Опции также делятся по типам:
1. Основные
2. Расширенные
3. Экспертные

Для получения справки по команде `ya make` используйте:
- `ya make -h`, `--help` — печатает справку.
- `ya make -hh` — для полного списка опций.
- `ya make -hhh` — для вывода списка опций, которые в том числе используются в конкретных сценариях.

### Опции сборки
На данный момент `ya make` поддерживает только локальную сборку.
В будущем планируется добавить распределенную сборку, для чего зарезервирована опция `--dist`.

По умолчанию код собирается в конфигурации `Debug` — без оптимизаций,с отладочной информацией и assert. 

Для типов сборок доступны следующие варианты:

- `-d`, `--debug`
Активирует сборку в режиме отладки.
Включает отладочную информацию в исполняемые файлы и снижает уровень оптимизации.
- `-r`, `--release`
Инициирует сборку в режиме релиза.
Оптимизирует исполняемый код для максимальной производительности в том числе удаляя отладочную информацию.
- `-v`, `--verbose`
Включает подробный режим вывода. Предоставляет дополнительную информацию о процессе сборки.
- `--rebuild`
Указывает игнорировать результаты предыдущих сборок и начать процесс заново.
- `--build=BUILD_TYPE`
Тип сборки

Полный актуальный список вариантов сборки можно посмотреть, выполнив:
```
ya make --help | grep 'Build type
```
или 
```
ya make --build help
```
Кроме параметра `--build` есть ещё ряд флагов, влияющих на тип сборки:
* `--lto/--thinlto` - сборка с глобальными оптимизациями (оптимизациями во время линковки, `LTO`) для C++;
* `--sanitize <sanitizer>` - сборка с санитайзером для С++;
* `--race` - сборка с race detector для Go.
* `--hardening` - сборка с более строгими проверками в коде
* `--musl` - сборка C/С++ c MUSL вместо `glibc`
* `--cuda=<optional|required|disabled>` - сборка с `CUDA`

Локальная сборка использует следующие ключи для настройки директорий:

- `-S=CUSTOM_SOURCE_ROOT`, `--source-root=CUSTOM_SOURCE_ROOT` — путь к проекту, из которого будет произведён поиск корня репозитория. По умолчанию это текущий рабочий каталог, где запущена команда ya make.
- `-B=CUSTOM_BUILD_DIRECTORY`, `--build-dir=CUSTOM_BUILD_DIRECTORY` — корень для сборочных директорий.
Здесь исполняются команды сборки. По умолчанию директории находятся в `~/.ya/build/`.

Директории для результатов сборки настраиваются следующими параметрами:
- `-o=OUTPUT_ROOT`, `--output=OUTPUT_ROOT` — путь для результатов сборки (на Linux и macOS используются хардлинки).
Результаты размещаются по указанному пути.

Можно указать, куда записывать логи сборки и событий:
- `--log-file=LOG_FILE` — добавляет подробный лог в указанный файл.
По умолчанию на каждую сборку создается свой лог в `~/.ya/logs/`.
- `--evlog-file=EVLOG_FILE` — записывает лог событий в указанный файл.
По умолчанию на каждую сборку создается свой лог в `~/.ya/evlogs/`.

Локальная сборка поддерживает режим контентных UIDов.
В этом режиме сборка не перезапускает команды, если результаты зависимостей не изменились.

Режим отключается опцией `--no-content-uids` или настройкой `content_uids = false` в `ya.conf`.

Чтобы увидеть использование контентных UIDов, воспользуйтесь опцией `--stat`:
```
[=] ya make path/test/content_uids_cache/simple/original --stat
Cache hit ratio is 71.43% (5 of 7). Local: 2 (28.57%), dist: 0 (0.00%), >>> by dynamic uids: 3 (42.86%) <<<
[CC-DYN_UID_CACHE] - 6 ms. <<<
[LD-DYN_UID_CACHE] - 2 ms. <<<
```
### Платформенные параметры

Платформа включает в себя компилятор, операционную систему и архитектуру процессора.
Например, `<clang11, Windows, x86_64>` или `<clang10, Android, armv8a>`.

По умолчанию в качестве целевой и сборочной платформы выбирается та, на которой запущена сборка. 
То есть операционная система будет соответствовать той, на которой вы работаете (например, Linux, Darwin (macOS) или Windows), архитектура будет x86_64 или arm64 (для Mac с процессором M1), а компилятор будет выбран по умолчанию (default) для данной операционной системы.

Чтобы изменить целевую платформу, используйте флаг `--target-platform`. 
Укажите тройку в формате `<компилятор-OS-архитектура>`, соединяя значения дефисами. 
Вы также можете указать только часть этой тройки, и недостающие компоненты будут автоматически заполнены значениями по умолчанию.
Для выбора компилятора по умолчанию используйте значение `DEFAULT`.

Примеры:
- `--target-platform clang-win-x86_64` — сборка для Windows на процессоре x86_64 с использованием компилятора Clang.
- `--target-platform default-android-armv8a` — сборка для Android на ARM в версии armv8a с компилятором по умолчанию.
- `--target-platform windows` — сборка для Windows на архитектуре x86-64 с компилятором по умолчанию.

### Сборочные переменные

В команде `ya make` можно указать дополнительные флаги (переменные) с помощью опции `-DVAR[=VALUE]`.
Если не указывать значение переменной, по умолчанию оно будет выставлено в yes.

Можно определить:
- Предопределённые переменные, позволяющие передать флаги для сборки  
`ya make` `-DLDFLAGS="-fblabla=foo -fbar"`, `ya make -DCFLAGS="-DNN_DOUBLE_PRECISION -Wno-strict-aliasing"`.
- Предопределённые переменные, управляющие конфигурацией, например `ya make -DCATBOOST_OPENSOURCE` (сборка как для open source) или `ya make -DCUDA_VERSION=10.1` (сборка с `CUDA`).
- Переменные для использования в `ya.make` `ya make -DMACRO1 -DMACRO2=42`, где в `ya.make` написано, например `IF (MACRO1)`.

### Настройки сборки

Процесс сборки в системе `ya make` описывается в файлах `ya.make`.
Эти файлы находятся рядом с кодом и включают все инструкции и параметры для сборки.
Описание в них высокоуровневое и использует макросы и модули.

Файл `ya.make` состоит из макросов, выполняющих разные функции. Они делятся на несколько категорий:

1. Сборочные макросы: например, `SRCS` для указания исходных файлов, `PEERDIR` для указания зависимостей.
2. Макросы интерпретации: например, `IF`, `INCLUDE` для условий и включений.
3. Макросы свойств сборки: например, `SET()`, `GRPC()`.
4. Макросы определения целей: например, `RECURSE`.
5. Макросы для внешних систем: например, `SUBSCRIBER`.

Большинство макросов не требуют явного указания команд для сборки.  
Команды — это скрытые свойства макросов, которые меняются в зависимости от параметров конфигурации.  
В макросах указываются только аргументы для этих команд.  
Макросы, такие как `SRCS`, могут сами определить команды для сборки по расширению файла.  

В типичном файле `ya.make` можно указать:
- Владельца модуля (`OWNER`) – обычно это имя пользователя или группа, ответственная за модуль.
- Тип сборки (`PROGRAM`, `LIBRARY`, `PY3_LIBRARY` и т.д.) – указывает, является ли модуль исполняемым файлом, библиотекой или чем-то иным.
- Источники (`SRCS`) – перечень файлов исходного кода, которые следует скомпилировать.
- Зависимости (`PEERDIR`, `DEPENDS`) – другие модули или библиотеки, от которых зависит текущий модуль.
- Параметры и флаги компиляции (`CFLAGS`, `LDFLAGS` и др.) для настройки процесса сборки.
Пример базового файла `ya.make`:
```
OWNER(user)
PROGRAM()
SRCS(main.cpp util.cpp)
PEERDIR(library/util)
```
Настройки сборки включают:
- [Отображение прогресса](#Отображение-прогресса): Вывод текущего статуса сборки в консоль. 
- [Управление результатами](#Результаты-сборки): Параметры для обработки и сохранения результатов сборки.
- [Контроль зависимостей](#Строгий-контроль-зависимостей): Проверка и контроль зависимостей модулей.

#### Отображение прогресса

Для вывода статуса сборки используется стиль ninja.
Прогресс отображается одной строкой, и показывает статус одной команды, со сведениями о других командах в конце строки (+X more).

Изменить вывод статуса на построчный можно опцией `-T`.  
Этот же режим включается при перенаправлении вывода команды `ya make` в файл.

Вывод команды `ya make` можно расширить следующими опциями:
  * `-v`, `--verbose` — выводить текст исполнившихся сборочных команд
  * `--do-not-output-stderrs` — не выводить stderr команд
  * `--show-timings` — выводить времена исполнения команд в статус, работает только с опцией `-T`
  * `--show-extra-progress` — выводить расширенный прогресс (количество исполненных команд) в статус. Работает только с `-T`
  * `--cache-stat` — перед сборкой выдать статистику по наполнению локального кэша
  * `--stat` — в конце сборки выдать статистику по сборке. Статистика включает использование кэшей, критический путь, самые долгие сборочные шаги и т.п.

#### Результаты Сборки

По умолчанию целями сборки являются модули, непосредственно указанные в `ya.make` директорий в командной строке, а также рекурсивно во всех макросах `RECURSE`, доступных из `ya.make` директорий в командной строке.

Это поведение может быть изменено следующими опциями:
- `--target/-C` — цели сборки и параметры среды.
- `-t`, `-A` — запуск тестов.
- `--force-build-depends` — включить зависимости для тестов без их запуска.
- `-DTRAVERSE_RECURSE_FOR_TESTS` — трактовать `RECURSE_FOR_TESTS` как обычный `RECURSE`.
- `--ignore-recurses` — игнорировать `RECURSE`, выполнять только указанные цели.
- `-o`, `--output <path>` — директория для хранения результатов.
- `--no-src-links` — отключение символических ссылок.
- `--keep-temps` — сохранить файлы в сборочных директориях.

Для расширения набора результатов сборки, можно использовать опцию `--add-result=.<suff>`.
В конфигурационном файле `ya.conf`можно задать `add_result = [".suff"]`. 
```
ya make -o=<output> <target> --add-result=.o --add-result=.obj
```
Складывает объектные файлы в директорию <output> и (на Linux и MacOS) создает ссылки на файлы из кэша результатов в директории с исходниками.

Дополнительные Опции:
  - `--add-protobuf-result` — Добавить все результаты генерации для `Protobuf`.
  - `--add-flatbuf-result` — Добавить результаты генерации `Flatbuffers`.
  - `--add-modules-to-results` — Сделать все модули (включая зависимые по `PEERDIR`) результатами сборки.
  - `--add-host-result=.<suff>` — Добавить выбранные результаты из сборочной платформы.
  - `--all-outputs-to-result` — Не фильтровать результаты команд.
  - Обычно `--add-result` фильтрует результаты команд по расширениям, с помощью этой опции можно запросить все результаты для команд, подходящих под `--add-result`.

Примеры:
    - `ya make --add-result=.pb.h` - результат только файлы `.pb.h`
    - `ya make --add-result=.pb.h --all-outputs-to-result` - результат как `.pb.h`, так и `.pb.cc`. 

Иногда хочется построить только генерируемые файлы, но не библиотеки/программы.  
Для этого служит опция `--replace-result`.  
Она оставит в результатах сборки только то, что выбрано в `--add-result`, все остальное будет удалено и не будет строиться совсем.

Множество отображаемых результатов можно ограничить с помощью:
  - `--no-output-for=.<suff>` — Ограничить множество отображаемых результатов.
  - `suppress_outputs = [".suff"]` — Параметр конфигурационного файла.

Эти опции не исключают файлы из сборки, они лишь говорят системе сборки, что результаты не надо складывать в рабочую копию и выходную директорию.  
Опция `--no-output-for` не взаимодействует с `--replace-result`.  
Файлы, исключенные из результатов, все равно будут построены и останутся в кэше.

#### Строгий контроль зависимостей
Для управления зависимостями между различными компонентами проекта в файлах `ya.make` используются макросы `PEERDIR` и `DEPENDS`.

Макрос `PEERDIR` указывает на другие модули внутри проекта, необходимые для сборки текущего модуля, обеспечивая правильное разрешение локальных зависимостей.  
`DEPENDS` может использоваться для объявления внешних зависимостей, которые требуют загрузки или специфической обработки перед сборкой.

Контроль зависимостей осуществляется на этапе конфигурирования: этот этап анализирует зависимости команд и присваивает всем необходимым файлам уникальные идентификаторы (UID).

### Работа с тестами 

По умолчанию локально результаты тестов не кэширутся.

На данный момент локальный запуск тестов учитывает таймауты в соответствии с размером (1 минута для SMALL, 10 для MEDIUM, час для LARGE).

По умолчанию, локальная сборка производится в конфигурации `debug`, а в автосборке `relwithdebinfo` (релизная с ассёртами), поэтому поведение и производительность тестов может отличаться. 

Результаты тестов локально складываются в директорию `test-results`, которая появляется символьной ссылкой в рабочей копии в директории теста (кроме Windows или при использовании флага `--no-src-links`).

Внутри находится директория `<suittype>/testing_out_stuff` в которой находятся логи тестов и прочие файлы, которые тесты порождают. 

Если тесты не прошли успешно, в консоль может быть выведена информация о путях в реальных директориях внутри сборочного каталога, где выполнялись тесты.  
Чтобы сохранить эти данные после завершения тестов, сборочные директории не очищаются сразу, а только при следующем запуске сборки.  
Таким образом, данные в этих каталогах доступны до следующей сборки или запуска тестов.  
Если вам необходимо сохранить эти данные, скопируйте их заранее.

#### Запуск тестов (-t, -tt, -ttt, -A)
- `-t`: Эта базовая опция запускает все тесты, отмеченные как “маленькие” (SMALL). Это быстрые тесты, обычно требующие мало ресурсов и времени для выполнения.
- `-tt`: Расширение базовой опции `-t`, которое включает в себя запуск тестов как “маленьких”, так и “средних” (MEDIUM) размеров. Средние тесты обычно занимают больше времени и ресурсов.
- `-ttt`: Данная опция запускает тесты всех размеров, включая “большие” (LARGE). Большие тесты часто включают в себя интеграционные и нагрузочные тесты, требующие значительного времени для выполнения и могут включать внешние зависимости.
- `-A, --run-all-tests`: Аналогично `-ttt`, запускает все тесты независимо от размера.

#### Управление выводом результатов
- `-L, --list-tests`: Выводит список тестов, которые будут выполнены, без их фактического запуска. Помогает разработчикам быстро проверить, какие тесты включены в план тестирования.
- `–fail-fast`: Прекращает выполнение тестового прогона сразу после первой встреченной неудачи. Эта опция полезна для экономии времени и ресурсов, особенно когда разработчики ищут конкретную ошибку.

#### Выборочное тестирование
- `–test-filter=TESTS_FILTERS`: Эта опция позволяет ограничить тестирование только определенными тестами, соответствующими указанным фильтрам. Это может быть имя теста, его часть или другой идентифицирующий шаблон.
- `–test-tag=TEST_TAGS_FILTER`: Позволяет запускать только те тесты, которые помечены определенными тегами. Теги — это пользовательские метки, которые могут быть нанесены на тесты для их группировки по определенным признакам или функциональности.
- `–test-size=TEST_SIZE_FILTERS`: Фильтр для запуска тестов определенного размера (SMALL, MEDIUM, LARGE), позволяющий более точно настроить объем запускаемых тестов в зависимости от текущих потребностей.
- `–test-type=TEST_TYPE_FILTERS`: Ограничивает запуск только теми тестами, которые относятся к указанным типам (например, UNITTEST, PYTEST). Удобно при необходимости проведения специфичных видов тестирования.

### Сообщения об ошибках

`ya make` предоставляет подробные сообщения об ошибках и предупреждениях, которые помогают идентифицировать и устранять проблемы в процессе сборки и тестирования. Эти сообщения могут включать информацию о недостающих файлах, циклических зависимостях, проблемах в конфигурации и многом другом. 
 
  * Конфигурационные ошибки (`BadAuto`, `BadDir`, и т.д.): Эти ошибки свидетельствуют о проблемах в настройках сборки, например, неправильно указанных директориях или файлах. Убедитесь, что все пути указаны корректно, и что ваши конфигурации соответствуют требованиям вашего проекта.
  * Ошибки зависимостей (`DEPENDENCY_MANAGEMENT`, `DupSrc`): Такие ошибки указывают на проблемы с управлением зависимостями, включая дублирование источников или некорректное управление зависимыми модулями. Для решения таких проблем проверьте объявления ваших зависимостей в файлах `ya.make` и устраните дубликаты или некорректные ссылки.
  * Синтаксические ошибки (`Syntax`): Ошибки синтаксиса часто возникают из-за неверного использования макросов или опечаток в файлах `ya.make`. Внимательно проверьте синтаксис ваших конфигурационных файлов на соответствие документации `ya make`.
  * Пользовательские ошибки (`UserErr`, `UserWarn`): Эти сообщения генерируются, когда `ya make` сталкивается с проблемами, непосредственно связанными с действиями пользователя, такими как неверное использование опций или несоответствие требованиям проекта.

### Популярные рецепты

* `ya make -r` - собрать код c оптимизациями и отладочной информацией 
* `ya make -v` - собрать в verbose-режиме. **Обратите внимание:** `ya -v make` и `ya make -v` имеют разный эффект. Первая добавляет вывод утилиты `ya`, вторая — сборки.
* `ya make -T` - собрать, не перезатирая выполняемые команды в выводе
* `ya make --add-result=".h" --add-result=".cpp"` - собрать, добавив в результаты сгенерированные в процессе сборки cpp- и h-файлы.
* `ya make --add-result=".pb.h" --add-result=".pb.cc" --replace-result`- запустить только кодогенерацию протобуфов.
* `ya make -t`  - запустить только быстрые тесты
* `ya make -tL` - вывести список быстрых тестов
* `ya make -A`  - запустить все тесты
