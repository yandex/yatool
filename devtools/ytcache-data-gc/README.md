# Important
Программа находится в статусе deprecated. Настоятельно рекомендуется вместе неё использовать команду `ya cache yt data-gc` - она быстрее, лучше масштабируется и имеет больше настроек.

# Intro
Вспомогательная утилита для поддержания YT cache (он же - distributed cache) в согласованном состоянии.
Очищает таблицу `data` от записей, на которые нет ссылок из таблицы `metadata`.

# Что под капотом

В двух словах реализация выглядит так:
1. считываем из metadata все значения поля `hash`
2. в таблице `data` ищем все строки, значение поля `hash` которых отсутствует в списке из предыдущего пункта
3. удаляем найденные строки

С первым пунктом всё просто: делаем запрос `select hash ...` (функция `devtools/ytcache-data-gc/cleaner.cpp::ReadKnownHashes()`).
Что касается второго, то наивная реализация сделать map по всей таблице `data` упирается в следующие ограничения:
- это работает чрезвычайно долго, и при падении или прерывании операции мы вообще ничего не удалим, то есть получается высокая цена сбоя.
- увеличивается потребление дискового пространства, что может вызвать переполнение дисковой квоты.

Поэтому второй и третий пункты сделаны более замысловато:
- из служебного атрибута `@pivot_keys` получаем оценку максимального значения ключа, по которому таблица разбита на таблеты. Это значение нужно, чтобы равномерно разбить весь диапазон ключей на равные отрезки. Количество отрезков считаем, разделив размер таблицы на константу `DATA_SIZE_PER_KEY_RANGE`. Другими словами, в один отрезок должно входить примерно `DATA_SIZE_PER_KEY_RANGE` байт. Этими вычислениями занимается функция `GetDataTableKeyRanges()`. На заметку: в коде есть неявное допущение, что ключ является беззнаковым целым, и его максимум меньше, чем `max(uint64) - 1`.
- итерируемся по отрезкам ключа, для каждого их них:
    - стартуем транзакцию, чтобы при любом раскладе временные данные были подчищены.
    - в транзакции запускаем (функция `RunJob()`) map-операцию по диапазону таблицы `data`, который задаётся отрезком ключа. Эта операция ищет "безхозные" строки и сохраняет их во временную таблицу. Строки, которые появились позже, чем `program start time - MIN_DATA_AGE_SECONDS`, игнорируются, чтобы случайно не удалить данные, которые появились после считывания `hash` из `metadata`.
    - из временной таблицы порциями (`MAX_CHUNK_SIZE`) вычитываем ключи найденных строк и удаляем их (функция `DeleteOrphanRows()`).
    - временную таблицу удаляем.

Какие плюсы такого подхода:
- диапазоны ключей привязаны к таблетам, поэтому за одну операцию напрягаем ограниченное количество таблетов и не мешаем остальным выполнять фоновое слияние чанков, что положительно сказывается на потреблении дискового пространства.
- относительно короткие map-операции (их трудоёмкость можно регулировать константой `DATA_SIZE_PER_KEY_RANGE`) реже вытесняются из вычислительного пула, поэтому время выполнения программы более предсказуемо.
- в случае падения на одном из отрезков, предыдущие отрезки будут обработаны, то есть какую-то полезную работу всё равно выполним.
