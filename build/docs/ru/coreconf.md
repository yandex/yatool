## Настройка и расширение системы сборки

Файл `ymake.core.conf` является основным конфигурационным файлом системы сборки `ymake` и играет ключевую роль в управлении процессом сборки проектов.

Он описывает макросы, модули, мультимодули, глобальные переменные, системные заголовки и другие аспекты конфигурации сборки.

Используя декларативный язык DSL (Domain-Specific Language), файл позволяет гибко настраивать правила для различных платформ, устанавливать шаблоны сборочных команд, определять их свойства и зависимости, а также управлять входами и результатами команд, связывая их в граф.

Конфигурационный файл `ymake.core.conf` позволяет:
- устанавливать правила настройки переменных для разных платформ и параметров;
- описывать макросы, их параметры и поведение;
- определять шаблоны сборочных команд с их дополнительными свойствами, такими как отображаемое имя или требуемые ресурсы;
- указывать входные и выходные данные для связывания команд в граф;
- применять макросы в зависимости от расширений файлов;
- задавать свойства модулей и связывать их с командами и между собой;
- устанавливать правила для модулей: их свойства и команды зависят от платформы и параметров;
- определять варианты мультимодулей и их зависимости.

### Правила настройки переменных
При описании модуля некоторые переменные можно сделать глобальными. Для этого используется свойство модуля `.GLOBAL`. Для обращения к глобальной переменной нужно добавить суффикс `_GLOBAL` к ее имени.

Пример:
```
module MY_MOD {
    .CMD=builder --list $MY_VAR_GLOBAL --extra $ANOTHER_VAR_GLOBAL
    .GLOBAL=MY_VAR ANOTHER_VAR
    ...

    SET(MY_VAR_GLOBAL $MODDIR)
    SET(ANOTHER_VAR_GLOBAL VERBOSE)
}
```
Во время конфигурации модуля глобальные переменные ведут себя как локальные. Можно получать только те значения, которые установлены в текущем модуле.
Однако на этапе выполнения (рендера) глобальная переменная собирает все значения, установленные во всех модулях, от которых зависит текущий модуль. Значения собираются в обратном порядке обхода графа зависимостей: от корня к листьям.
Т.е. значения из корневых узлов будут в конце списка, а из листовых — в начале.

**Пример зависимости:**
```

  ┌─────► lib-mid1──────┐
  │                     ▼
main                  lib-leaf
  │                     ▲
  └─────► lib-mid2──────┘

```
Для конечного модуля `main` сборочные команды будут выглядеть так:

```bash
# lib-leaf
builder --list lib-leaf --extra VERBOSE

# lib-mid1
builder --list lib-leaf lib-mid1 --extra VERBOSE VERBOSE

# lib-mid2
builder --list lib-leaf lib-mid2 --extra VERBOSE VERBOSE

# main
builder --list lib-leaf lib-mid1 lib-mid2 main --extra VERBOSE VERBOSE VERBOSE VERBOSE
```
Разворачивание глобальных переменных происходит на этапе рендера. Это означает, что модификаторы `input` и `output` на глобальных переменных не добавят дополнительные зависимые ребра в граф. Однако для обработки значений можно использовать фильтры и форматеры (например, `suf`, `pre`, `join`, `ext`).

Пример использования:
```bash
${pre=arc/;suf=/bin:MY_VAR_GLOBAL}
```

В проекте также существуют предопределенные глобальные переменные, такие как `PEERS`.

Для глобальных ресурсов действуют особые правила. Если глобальный ресурс определен в нескольких модулях, все определения должны быть идентичны.
При несовпадении значений это приводит к ошибке конфигурации.

Пример глобального ресурса:
```
{resource:RESOURCES_URIS_GLOBAL}
```

В рендере глобального ресурса используется только одно значение, последующие объявления игнорируются.

Глобальные переменные и ресурсы облегчают распространение параметров и настроек между модулями, что упрощает управление сложными зависимостями и конфигурациями проекта.

### Основные принципы по написанию макросов.

Макросы используются для создания повторно используемых блоков кода, которые выполняют определенные задачи, такие как настройка модулей, установка переменных, отключение функциональности и многое другое. 

Условно макросы можно разделить на две группы:

1. Макросы, задающие свойства: Эти макросы вызывают другие макросы, формируют переменные, которые будут использованы в командах других макросов или модуля. Кроме того, такие макросы могут добавлять зависимости или устанавливать свойства модуля.
2. Макросы, описывающие команды: Эти макросы описывают команды, которые должны быть исполнены в процессе сборки. Макрос формирует команду, которая встраивается в сборочный граф своего модуля за счёт связывания своих результатов с входами других команд (потребителей) и, возможно, своих входов с результатами других команд (источников). Такие макросы и формируют сборочный граф, который исполняется в процессе сборки.

Определение макроса осуществляется посредством ключевого слова `macro`, за которым следует имя макроса. Макрос может также принимать параметры, которые указываются в скобках сразу после его имени. При выхове макроса параметры указываются через пробел.

Пример:
```plaintext
macro MY_MACRO(PARAM1, PARAM2) {
   // Код макроса
 }
```
Параметры делятся на три типа: строки, списки строк и булевы. Они могут быть именованными и неименованными.

**Неименованные параметры** участвуют в вызове своим значением:
- Скалярные — строка (одно слово). Может быть опциональным.
В документации обозначается как `<значение>` (обязательный) или `[<значение>]` опциональный.
Важно, что слово, обозначающее значение, в таком случае одно и оно не целиком заглавными буквами.

Примеры:
```plaintext
  ### @usage: PY_NAMESPACE(<name.space>)
  PY_NAMESPACE(my.namespace)
  ### @usage: KV(<Key> <Value>)
  KV(the_key, the_value) # Key=the_key, Value=the_value
```
- Свободно-списочные — список слов, не отнесённых к другим параметрам.
В документации обозначается как `Значение...`.

 Примеры:
```plaintext
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  ALL_SRCS(x.cpp GLOBAL y.cpp)       # Filenames=x.cpp y.cpp, GLOBAL=True
  
  ### @usage: SRC(<File>, Flags...)
  SRCS(x.cpp -Wno-error -std=c++17)  # Flags=-Wno-error -std=c++17
  SRCS(y.cpp)                        # Flags=<empty>
```
**Именованные параметры**  обозначены именем и возможным значением. Используются [SCREAMING_SNAKE_CASE](https://ru.wikipedia.org/wiki/Snake_case):
- Булевы — определяются в описании макроса по наличию в списке. В документации такой параметр описывается как `[PARM_NAME]`. Важно, что в данном случае имя параметра написано целиком большими буквами и без угловых скобок.

Пример:
 ```plaintext
  ### @usage: ALL_SRCS([GLOBAL] Filenames...)
  ALL_SRCS(GLOBAL x.cpp y.cpp)  # GLOBAL is True
  ALL_SRCS(a.cpp b.cpp)         # GLOBAL is False
 ```
- Скалярные — строка (одно слово) после имени параметра. Может быть опциональным. В документации такой параметр выглядит как `NAME <value>` или `[NAME <value>]`. Имя параметра целиком большими буквами, а значение — одно слово в угловых скобках.

Пример:
 ```plaintext
  ### @usage: COMPILE_LUA(Src, [NAME <import_name>])
  .
  COMPILE_LUA(func.lua NAME my.func)  # NAME=my.func
  COMPILE_LUA(the_func.lua)           # NAME=<default>
  ```
- Списочные — список слов после имени параметра и до следующего имени или закрывающей скобки. Может встречаться несколько раз. В документации такой параметр выглядит как `NAME <list of values>` или `[NAME <list of values>]`. Имя параметра целиком большими буквами, а значение — несколько слов в угловых скобках. 

Примеры:
 ```plaintext
  ### @usage: FROM_ARCHIVE(Src [RENAME <resource files>] OUT <output files> [PREFIX <prefix>] [EXECUTABLE])
  # Src    - обязательный неименованный скалярный
  # RENAME - опциональный именованный списочный
  # OUT    - обязательный именованный списочный
  # PREFIX - опциональный именованный скалярный
  # EXECUTABLE - булев
  .
  FROM_ARCHIVE(
      resource.tar.gz
      PREFIX y
      RENAME y/a.txt OUT y/1.txt
      RENAME y/b/c.txt OUT y/2.txt
      RENAME RESOURCE OUT 3.tar.gz
      OUT y/d.txt
  )
  # Src=resource.tar.gz 
  # PREFIX=y
  # RENAME=y/a.txt y/b/c.txt RESOURCE  ## RESOURCE в данном случае значение, а не имя параметра
  # OUT=y/1.txt y/2.txt 3.tar.gz y/d.txt
  ```
Условия в макросах могут быть заданы для выполнения действий в зависимости от значений переменных. Эти условия определяются с помощью ключевого слова `when` и проверяются на истинность.

Правила (триггеры) задают значения переменных на основе других переменных. Условные выражения в языке конфигурации не исполняются в последовательности их написания, а активируются при изменении значения соответствующего условия. Работают декларативно, а не императивно, поэтому вместо конструкции `if/then/else` используется синтаксис `when/elsewhen/otherwise`.

Пример:
```plaintext
   macro CONDITIONAL_SET(CONDITION) {
       when ($CONDITION == "yes") {
           SET(VAR "value1")
       }
       otherwise {
           SET(VAR "value2")
       }
   }
```
Отключение функциональности в макросах осуществляется с использованием функции `DISABLE` для отключения определённых функций или зависимостей, а включение осуществляется с помощью функции `ENABLE`.

Пример:
   ```plaintext
### @usage: WERROR()
### Consider warnings as errors in the current module.
### In the bright future will be removed, since WERROR is the default.
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro WERROR() {
    ENABLE(WERROR)
}

### @usage: NO_WERROR()
### Override WERROR() behavior
### Priorities: NO_COMPILER_WARNINGS > NO_WERROR > WERROR_MODE > WERROR.
macro NO_WERROR() {
    DISABLE(WERROR)
}
```
Макросы могут использовать глобальные переменные и атрибуты, которые влияют на поведение всего проекта.

### Основные принципы по написанию модулей.

Модуль задает правила сборки команды, а также ряд дополнительных свойств:
- Как формируется имя модуля.
- Что является автоматическими входами его команд.
- Как он связывается с другими модулями
- Какие макросы допустимы, а какие нет в описании его сборки
- Переименование макросов для по-модульного полиморфизма.

Модули определяют различные компоненты проекта, такие как библиотеки, исполняемые файлы, тесты и другие. 

Модуль определяется с использованием ключевого слова `module` и имени модуля. Он может наследовать свойства и поведение от другого модуля, указываемого после двоеточия. Это позволяет избежать дублирования общих свойств между модулями. 

Например, модули `PROGRAM` и `DLL` наследуются от модуля `_LINK_UNIT`, который задает общие свойства, связанные с возможностью линковки библиотек.

Свойства наследника могут либо переопределять свойства предка, либо объединяться, в зависимости от конкретного свойства. При этом макросы модуля предка будут вызываться раньше, чем макросы модуля наследника.

Пример:
```plaintext
module MY_LIBRARY: _LIBRARY {
       // Код модуля
}
```
Внутри модуля можно устанавливать переменные с помощью встроенного макроса `SET` и вызывать другие функции для выполнения определенных действий. Модули могут содержать условия, зависящие от значений переменных. Модуль может иметь локальные переменные, которые могут изменить поведение как его собственной команды, так и других команд, связанных с его сборкой. На основе переменных также могут быть определены условные правила поведения модуля.

Пример:
```plaintext
module MY_LIBRARY: _LIBRARY {
  when ($CONDITION == "yes") {
       SET(MODULE_TYPE LIBRARY)
       SET(MODULE_LANG CPP)
   }
}
```
Модуль позволяет устанавливать различные атрибуты, которые определяют его функциональные возможности и свойства. 
Эти атрибуты могут включать глобальные переменные и другие параметры, которые оказывают влияние на поведение и работу всего проекта.

Пример:
```plaintext
module MY_LIBRARY: _LIBRARY {
    .GLOBAL=_AARS _PROGUARD_RULES
    .SEM=CPP_LIBRARY_SEM
    .DEFAULT_NAME_GENERATOR=ThreeDirNames
    SET(MODULE_TYPE LIBRARY)
    SET(MODULE_LANG CPP)
}
```
Список доступных макросов и модулей непрерывно растет. 
Для поддержания актуальности, на основе комментариев и описаний автоматически генерируется документация, содержащая информацию обо всех доступных на данный момент макросах и модулях.

### Плагины

Ядро системы сборки поддерживает расширение функциональности с помощью плагинов на `Python` и `C++`. Несмотря на то, что код на `Python` обрабатывается медленнее по сравнению с встроенным `DSL`, он позволяет обойти некоторые ограничения встроенного языка.

С помощью `Python` можно:
- Писать макросы, задающие свойства и описывающие команды.
- Выполнять парсинг зависимостей.

Код для плагинов на `Python` размещается в директории `build/plugins`. Реализации макросов представляют собой функции `Python` вида `on<имя_макроса>`. Например, реализация макроса `PY_SRCS` будет представлена функцией `onpy_srcs`.

Плагины на `Python` загружаются во время выполнения сборки и интерпретируются ядром системы сборки, в которое встроен интерпретатор `Python`. Это означает, что любые изменения в плагинах, как и в конфигурации, не требуют релиза системы сборки.

Система сборки также поддерживает расширение с помощью плагинов на `C++`. Эти плагины встроены в ядро системы сборки, но реализуются не в основной логике ядра, а как отдельные сущности, вызываемые через интерфейс плагинов.

Преимущества плагинов на `C++` является высокая скорость выполнения и возможность добавлять команды в граф.

Недостаток в том, что плагины на `C++` требуют релизного цикла. Из-за того, что они встроены в ядро, их релиз происходит вместе с ним. При локальной разработке и тестировании таких плагинов необходимо пересобирать ядро системы сборки (программа `devtools/ymake/bin`).

Например, макрос `RESOURCE` реализован с использованием плагина на `C++`.

Плагины применяются в макросах, которые могут принимать параметры для настройки поведения. При использовании плагинов необходимо учитывать их зависимости от других модулей или библиотек, которые должны быть указаны с помощью `PEERDIR`. Также важно корректно указывать путь к плагину и его имя в макросе, чтобы система сборки могла правильно их использовать.

### Скрипты.

Скрипты в системе сборки — это ключевой элемент для реализации специфичных сборочных команд проекта.
Они помогают справиться с задачами, которые не покрываются стандартными инструментами сборки, и предоставляют дополнительные возможности для адаптации и расширения функциональности сборочного процесса.

Скрипты размещаются в директории `build/scripts`. 
Это централизованное место хранения, где находятся все нужные скрипты для управления сборкой проекта.

Для написания скриптов используется язык программирования `Python`.

Вызов скриптов в системе сборки осуществляется с помощью макросов. 
Макросы описывают команды, которые нужно выполнить во время сборки, и помогают встроить эти команды в сборочные графы модулей. Это достигается связыванием результатов выполнения одних команд с входами других (потребителей) и, возможно, входов с результатами других команд (источников).

Скрипты поддерживают передачу различных параметров, что позволяет гибко настраивать команды под конкретные задачи сборки. Параметры передаются через макросы и могут включать пути к файлам, опции компиляции, флаги и другие важные данные.

**Пример макроса для вызова скрипта**

```make
macro CUSTOM_BUILD_STEP(Param1, Param2) {
    .CMD=YMAKE_PYTHON ${input:“build/scripts/my_build_script.py”} ${input:Param1} ${output:Param2}
}
```
- {input:"build/scripts/my_build_script.py"} — путь к вашему скрипту.
- {input:Param1} и {output:Param2} — параметры, передаваемые в скрипт.

### Ошибка UnkStatm

Ошибка `UnkStatm` возникает в случае вызова неизвестного макроса в файле сборки проекта `ya.make`. В файлах описания сборки запрещено использовать макросы, имена которых начинаются с символа подчеркивания. Макросы, которые можно использовать в сборке, описаны в `ymake.core.conf` или в плагинах `build/plugins`.